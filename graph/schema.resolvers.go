package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"errors"
	"fmt"
	"lms_backend/engine/users"
	"lms_backend/graph/model"

	_ "github.com/lib/pq"
)

// SignupUser is the resolver for the SignupUser field.
func (r *mutationResolver) SignupUser(ctx context.Context, email string, password string, name string) (*model.User, error) {
	// Implement your logic for signing up a new user here
	// Check if a user with the given email already exists
	existingUser, err := users.FindUserByEmail(email)
	if err != nil {
		return nil, err
	}
	if existingUser != nil {
		return nil, fmt.Errorf("user with email %s already exists", email)
	}

	// Create a new user with the given email, password, and name
	user := &model.User{
		ID:       users.GenerateID(),
		Email:    email,
		Password: password,
		Name:     name,
		Role:     existingUser.Role, //should be checked again
	}

	// Add the new user to the database
	err = users.AddUser(user)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// LoginUser is the resolver for the LoginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, email string, password string) (*model.User, error) {
	// Implement your logic for logging in a user here
	// You may want to check that the email and password match a user in your database
	// Find the user with the given email
	user, err := users.FindUserByEmail(email)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("user with email %s not found", email)
	}

	// Hash the given password and compare it to the hashed password in the database
	hashedPassword := users.HashPassword(password)
	if user.Password != hashedPassword {
		return nil, errors.New("incorrect password")
	}

	return user, nil
}

// UpdateUser is the resolver for the UpdateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, email string, password string, name string) (*model.User, error) {
	// Implement your logic for updating a user here
	// You may want to check that the ID matches a user in your database
	// Find the user with the given ID
	user, err := users.FindUserByID(id)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("user with ID %s not found", id)
	}

	// Validate the email and name
	if !users.ValidateEmail(email) {
		return nil, errors.New("invalid email")
	}
	if !users.ValidateName(name) {
		return nil, errors.New("invalid name")
	}

	// Hash the password
	hashedPassword := users.HashPassword(password)

	// Update the user's email, password, and name
	user.Email = email
	user.Password = hashedPassword
	user.Name = name

	// Save the updated user to the database
	err = users.UpdateUser(user)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// DeleteUser is the resolver for the DeleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.User, error) {
	// Implement your logic for deleting a user here
	// You may want to check that the ID matches a user in your database
	// Find the user with the given ID
	user, err := users.FindUserByID(id)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("user with ID %s not found", id)
	}

	// Delete the user from the database
	err = users.DeleteUser(user)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// RequestPasswordReset is the resolver for the RequestPasswordReset field.
func (r *mutationResolver) RequestPasswordReset(ctx context.Context, email string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: RequestPasswordReset - RequestPasswordReset"))
}

// ResetPassword is the resolver for the ResetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token *string, password string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: ResetPassword - ResetPassword"))
}

// Users is the resolver for the Users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	// Implement your logic for returning a list of users here
	// Query the database for a list of users
	users, err := users.ListUsers()
	if err != nil {
		return nil, err
	}

	return users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
