package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"fmt"
	"lms_backend/graph/model"
	"errors"
	"crypto/rand"
	"encoding/hex"
	"crypto/sha256"
	
	
)

// SignupUser is the resolver for the SignupUser field.
func (r *mutationResolver) SignupUser(ctx context.Context, email string, password string, name string) (*model.User, error) {
	// Implement your logic for signing up a new user here
	// Check if a user with the given email already exists
	existingUser, err := findUserByEmail(email)
	if err != nil {
		return nil, err
	}
	if existingUser != nil {
		return nil, fmt.Errorf("user with email %s already exists", email)
	}

	// Create a new user with the given email, password, and name
	user := &model.User{
		ID:       generateID(),
		Email:    email,
		Password: password,
		Name:     name,
	}

	// Add the new user to the database
	err = addUser(user)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// LoginUser is the resolver for the LoginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, email string, password string) (*model.User, error) {
	// Implement your logic for logging in a user here
	// You may want to check that the email and password match a user in your database
	// Find the user with the given email
	user, err := findUserByEmail(email)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("user with email %s not found", email)
	}

	// Hash the given password and compare it to the hashed password in the database
	hashedPassword := hashPassword(password)
	if user.Password != hashedPassword {
		return nil, errors.New("incorrect password")
	}

	return user, nil
}

// UpdateUser is the resolver for the UpdateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, email string, password string, name string) (*model.User, error) {
	// Implement your logic for updating a user here
	// You may want to check that the ID matches a user in your database
	// Find the user with the given ID
	// Find the user with the given ID
	user, err := findUserByID(id)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("user with ID %s not found", id)
	}

	// Validate the email and name
	if !validateEmail(email) {
		return nil, errors.New("invalid email")
	}
	if !validateName(name) {
		return nil, errors.New("invalid name")
	}

	// Hash the password
	hashedPassword := hashPassword(password)

	// Update the user's email, password, and name
	user.Email = email
	user.Password = hashedPassword
	user.Name = name

	// Save the updated user to the database
	err = updateUser(user)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// DeleteUser is the resolver for the DeleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.User, error) {
	// Implement your logic for deleting a user here
	// You may want to check that the ID matches a user in your database
	return &model.User{
		ID:       id,
		Email:    "",
		Password: "",
		Name:     "",
	}, nil
}

// Users is the resolver for the Users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	// Implement your logic for returning a list of users here
	return []*model.User{
		{
			ID:       "123",
			Email:    "john@example.com",
			Password: "password",
			Name:     "John Smith",
		},
		{
			ID:       "456",
			Email:    "jane@example.com",
			Password: "password",
			Name:     "Jane Smith",
		},
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }


// findUserByEmail finds a user with the given email in the database.
func findUserByEmail(email string) (*model.User, error) {
	// Replace this placeholder implementation with your own database query
	if email == "john@example.com" {
		return &model.User{
			ID:       "123",
			Email:    "john@example.com",
			Password: "password",
			Name:     "John Smith",
		}, nil
	}
	return nil, nil
}

// addUser adds a user to the database.
func addUser(user *model.User) error {
	// Replace this placeholder implementation with your own database query
	if user.Email == "john@example.com" {
		return errors.New("user with email john@example.com already exists")
	}
	return nil
}

// generateID generates a unique identifier.
func generateID() string {
	// Generate a random 16-byte slice
	b := make([]byte, 16)
	_, err := rand.Read(b)
	if err != nil {
		// This should never happen, but if it does, return an empty ID
		return ""
	}

	// Encode the random bytes as a hexadecimal string
	return hex.EncodeToString(b)
}

// hashPassword hashes a password using SHA-256.
func hashPassword(password string) string {
	h := sha256.New()
	h.Write([]byte(password))
	return hex.EncodeToString(h.Sum(nil))
}

// validateEmail returns true if the given string is a valid email address.
func validateEmail(email string) bool {
	re := regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
	return re.MatchString(email)
}

// validateName returns true if the given string is a valid name.
func validateName(name string) bool {
	if len(name) < 2 || len(name) > 100 {
		return false
	}
	for _, c := range name {
		if !unicode.IsLetter(c) && !unicode.IsSpace(c) {
			return false
		}
	}
	return true
}

// hashPassword hashes a password using SHA-256.
func hashPassword(password string) string {
	h := sha256.New()
	h.Write([]byte(password))
	return hex.EncodeToString(h.Sum(nil))
}

// findUserByID finds a user with the given ID in the database.
func findUserByID(id string) (*model.User, error) {
	// Replace this placeholder implementation with your own database query
	if id == "123" {
		return &model.User{
			ID:       "123",
			Email:    "john@example.com",
			Password: "password",
			Name:     "John Smith",
		}, nil
	}
	return nil, nil
}

// updateUser updates a user in the database.
func updateUser(user *model.User) error {
	// Replace this placeholder implementation with your own database query
	if user.ID != "123" {
		return fmt.Errorf("user with ID %s not found", user.ID)
	}
	return nil
}